var _a, _b, _c, _d;
import { __decorate, __metadata } from "tslib";
import { Injectable, NgZone, Injector } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';
import { ApiBase } from '@plano/shared/api/base/api-base';
import { Id } from '@plano/shared/api/base/id';
import { Meta } from '@plano/shared/api/base/meta';
import { ApiAttributeInfo } from '@plano/shared/api/base/api-attribute-info';
import { PApiPrimitiveTypes } from '@plano/shared/api/base/generated-types.ag';
import { ApiObjectWrapper } from '@plano/shared/api';
import { ApiErrorService } from '@plano/shared/api/api-error.service';
/**
 * This service enables access to the api "email_valid".
 * This file is auto generated by de.sage.scheduler.api_generator.ApiGenerator.
 */
// constants
class Consts {
    constructor() {
        this.INVALID = 1;
        this.USED = 2;
        this.FAULTY_EMAIL = 3;
    }
}
let EmailValidApiService = class EmailValidApiService extends ApiBase {
    constructor(h, router, apiE, zone, injector) {
        super(h, router, apiE, zone, injector, 'email_valid');
        this.consts = new Consts();
        this.dataWrapper = new EmailValidApiRoot(this);
    }
    version() {
        return 'afd2426e43b85d8523149fb4951acb5e,3cf23f89747a03c3f7ed8329d165c940';
    }
    get data() {
        return this.dataWrapper;
    }
    getRootWrapper() {
        return this.dataWrapper;
    }
    recreateRootWrapper() {
        this.dataWrapper = new EmailValidApiRoot(this);
    }
};
EmailValidApiService = __decorate([
    Injectable({
        providedIn: 'root',
    }),
    __metadata("design:paramtypes", [typeof (_a = typeof HttpClient !== "undefined" && HttpClient) === "function" ? _a : Object, typeof (_b = typeof Router !== "undefined" && Router) === "function" ? _b : Object, ApiErrorService, typeof (_c = typeof NgZone !== "undefined" && NgZone) === "function" ? _c : Object, typeof (_d = typeof Injector !== "undefined" && Injector) === "function" ? _d : Object])
], EmailValidApiService);
export { EmailValidApiService };
export class EmailValidApiRoot extends ApiObjectWrapper {
    constructor(api, idRaw = null) {
        super(api, EmailValidApiRoot);
        this.api = api;
        this._id = null;
        this.attributeInfoThis = new ApiAttributeInfo({
            apiObjWrapper: this,
            name: '',
            id: 'ROOT',
            canEdit: () => false,
            readMode: () => true,
        });
        this.attributeInfoInvalid = new ApiAttributeInfo({
            apiObjWrapper: this,
            name: 'invalid',
            id: 'INVALID',
            primitiveType: PApiPrimitiveTypes.boolean,
            canEdit: () => false,
            readMode: () => true,
        });
        this.attributeInfoUsed = new ApiAttributeInfo({
            apiObjWrapper: this,
            name: 'used',
            id: 'USED',
            primitiveType: PApiPrimitiveTypes.boolean,
            canEdit: () => false,
            readMode: () => true,
        });
        this.attributeInfoFaultyEmail = new ApiAttributeInfo({
            apiObjWrapper: this,
            name: 'faultyEmail',
            id: 'FAULTY_EMAIL',
            primitiveType: PApiPrimitiveTypes.Email,
            canEdit: () => false,
            readMode: () => true,
        });
        this._updateRawData(Meta.createNewObject(false, idRaw), true);
        // set parent attribute
    }
    get id() {
        return this._id !== null ? this._id : Id.create(Meta.getNewItemId(this.rawData));
    }
    /**
     *  Is a passed email address not valid?
     *
     * @type {boolean}
     */
    get invalid() {
        return this.data[1];
    }
    set invalidTestSetter(v) {
        this.setterImpl(1, v, 'invalid');
    }
    /**
     *  Is a passed email address already used?
     *
     * @type {boolean}
     */
    get used() {
        return this.data[2];
    }
    set usedTestSetter(v) {
        this.setterImpl(2, v, 'used');
    }
    /**
     *  When one of the error booleans are true then this value contains the email address which triggered the error. Note, that this api stops checking finding the first error. So, this value is not a list but a potentially only a single email address.
     *
     * @type {Email}
     */
    get faultyEmail() {
        return this.data[3];
    }
    set faultyEmailTestSetter(v) {
        this.setterImpl(3, v, 'faultyEmail');
    }
    _fixIds(_idReplacements) {
    }
    _updateRawData(data, generateMissingData) {
        super._updateRawData(data, generateMissingData);
        this.data = data;
        // update id wrapper
        const idRawData = Meta.getId(data);
        this._id = idRawData === null ? null : Id.create(idRawData);
        // create missing/default data
        if (generateMissingData && data) {
            this.fillWithDefaultValues(data, 4);
            data[1] = false;
            data[2] = false;
        }
        // propagate new raw data to children
    }
    get dni() {
        return '1';
    }
    static loadDetailed(api, id, { success = null, error = null, searchParams = null } = {}) {
        return ApiObjectWrapper.loadDetailedImpl(api, id, '1', { success: success, error: error, searchParams: searchParams });
    }
    assumeValidated() {
        // TODO: PLANO-151346
    }
}
//# sourceMappingURL=email-valid-api.service.ag.js.map